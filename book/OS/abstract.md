# 操作系统导论

---

## 虚拟化

### 抽象:进程

- 进程：操作系统为正在运行的程序提供的抽象。

- 进程的状态：
    1. 运行：进程正在处理器上运行
    2. 就绪：进程已经准备好运行，由于某种原因，操作系统选择不在此时运行
    3. 阻塞:一个进程执行了某种操作，知道发生其他事件时才会准备运行。IO等
    ![进程状态转换](../img/process-status.png)

- 进程切换
    协作方式：操作系统相信系统的进程会合理的运行，运行时间长的进程，会自愿放弃CPU，以便操作系统可以执行其他任务。
    非协作方式：时钟中断，每隔一段时间，产生一次中断，此时正在运行中的进程停止，操作系统获得CPU的控制权，停止当前进程，并启动另外一个进程。

- 上下文切换:context switch
    操作系统为当前正在执行的进程保存一些寄存器的值，并为即将执行的进程恢复一些寄存器的值。

- 进程调度策略:
  
  - 假设 ：
  
    > 1. 每一个工作运行相同的时间
    > 2. 所有的工作同时到达
    > 3. 一旦开始，每个工作保持运行直到完成
    > 4. 所有的工作只是使用CPU
    > 5. 每个工作的运行时间是已知的
  
  - 评价指标:周转时间  T~周转~ = T~完成~ - T~到达~
  - 新度量指标：响应时间 T~响应时间~ = T~首次运行~  - T~到达时间~

1. FIFO (FCFS first come first server):先进先出，先来先服务

   A:10  B:20 C:30    T = (10+20+30)/3 = 20 平均周转时间 20

    >问题：极端情况下：A:100  B:10  C:10   T = （100+110+120）/3 = 110   ,A为长任务，BC必须等到A执行完后开始执行，对于BC的执行时间10 ，周转时间110 ，效率不高。  SJF(短任务优先)  解决FCFS的极端情况

2. SJF (最短任务优先)

   FCFS的极端情况： A:100  B:10  C:10      T~周转~ = 110
   SJF调度后： T~周转~ = （10 +20 +120）/3 = 50   由110 下降至50

   >问题：SJF 基于所有任务同时到达，是一个好的调度算法，放宽限制
   A:100  t=0   B:10  t=10   C:10  t=10
   BC 到达时，A已经在运行，根据假设三 ，T~周转~ = （100 +(110-10)+(120-10) ）/3 = 103.3  遇到了FCFS的极端问题
   STCF（最短完成时间优先）放宽假设三 ，工作可抢占

3. STCF(虽短完成任务优先)
  SJF是非抢占式的，STCF 抢占式(shortest time-to-completion first).新工作进入系统时，会确认剩余工作中和新工作中，谁的剩余时间最短，然后调度该工作。
  A:100  t=0   B:10  t=10   C:10  t=10
  ![STCF](../img/STCf.png)
  T~周转~ = ((120-0)+(20-10)+(30-10))/3 = 50  // 非抢占式的SJF T~周转~ = 103.3 ,巨大提升

   >问题： 如果后续的工作一直是短任务，A任务将无法执行，提出响应时间的概念

4. 轮转（RR）：
  RR在一个时间片内运行一个任务，然后切换到运行队列中的下一个任务，而不是运行到一个任务结束 。RR反复执行，直到所有任务完成。
  A:5   B:5  C:5  t=0 同时到达，时间片1s
  ![RR](../img/RR.png) 时间片的长度对RR非常重要 . 时间片越短，RR 的响应时间越好，时间片过短会造成大量的上下文切换，影响整体的性能。
    >RR调度，注重的是公平，在效率上比较差.
    放宽上述假设4，5  有IO操作，作业时间未知
5. **MLFQ(multi-level feedback queue):多级反馈队列**

    >需要解决两个问题
    >
    >1. 优化周转时间
    >2. 降低响应时间

    基本规则：

    MLFQ拥有许多独立的队列，每个队列有不同的优先级。在任何时刻，一个工作只能存在于一个队列中，MLFQ总是优先执行较高  优先级的队列。

    对于队列的中任务，具有相同的优先级，采用RR进行调度 。
    >规则1：如果A 的优先级 > B 的优先级 ，运行A
    规则2：如果A的优先级 = B的优先级，RR调度运行AB

    ![MLFQ](../img/mlfq.png)

    尝试1：改变优先级
      >规则3 工作进入系统时，放在最高优先级队列 ，（假设新工作均为短任务）
    >规则4 工作用完整个时间片后，降低其优先级（移入下一级队列）
    >如果工作在其时间片内主动释放CPU ，则优先级不变  （优化IO任务的响应时间)

      问题：新工作一直是短任务或交互式任务，长任务得不到CPU执行，会产生饥饿。故意调用IO，影响调度公平。

      尝试2：在特定的时间间隔内，提升所有的工作。例如，全部提升到最高优先级的队列。保证长任务可以得到执行。
      > 规则5：经过一段时间S，将系统中所有的工作重新加入最高优先级队列。

      尝试3：更好的计时方式 。
      >规则4:（修改） 一旦工作用完了其在一层中的时间配额，就降低其优先级 。

    优化：不同的优先队列拥有不用的时间片。

6. 比列份额（彩票调度）and 步长调度  (使用较少)
彩票数代表进程（用户或其他）占有某个资源的份额.通过不断的抽取彩票,彩票调度从概率上获得这种份额的比例.

7. **多处理器的额调度**  TODO: 学习并发之后再阅读。

---

### 抽象：地址空间   CPU虚拟化

#### 机制：地址转换

地址转换:基于硬件的地址转换。利用地址转换，硬件对每次内存访问进行处理，将指令中的虚拟地址转换为数据实际储存的物理地址。

> 假设：
用户的地址空间必须连续的放在物理内存中，同时为了简单，我们假设地址空间小于物理内存大小。

方案1 ： 动态(基于硬件)重定位
> 每个CPU中需要两个硬件寄存器：基址寄存器（base） + 界限寄存器（bound）
一个基址寄存器将虚拟地址转换为物理地址，一个界限寄存器确保这个地址在进程地址空间的范围内

`physical addresss = virtual address + base`

## 并发

## 持久化
